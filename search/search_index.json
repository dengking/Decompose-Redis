{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u5173\u4e8e\u672c\u5de5\u7a0b Redis is simple but powerful, it can be a great learning material. I decompose it into modules and conquer each. It can be divide into modules as below \u5173\u4e8eredis redis Redis cn \u6587\u6863 Redis data structure Redis network module Redis event library Redis memory management","title":"Home"},{"location":"#_1","text":"Redis is simple but powerful, it can be a great learning material. I decompose it into modules and conquer each. It can be divide into modules as below","title":"\u5173\u4e8e\u672c\u5de5\u7a0b"},{"location":"#redis","text":"redis Redis cn \u6587\u6863","title":"\u5173\u4e8eredis"},{"location":"#redis#data#structure","text":"","title":"Redis data structure"},{"location":"#redis#network#module","text":"","title":"Redis network module"},{"location":"#redis#event#library","text":"","title":"Redis event library"},{"location":"#redis#memory#management","text":"","title":"Redis memory management"},{"location":"TODO/","text":"TODO Cache replacement policies \u5728\u9605\u8bfbredis\u7684\u6e90\u4ee3\u7801\u7684\u65f6\u5019\uff0c \u53d1\u73b0\u4e86\u5982\u4e0b\u7684\u5b9a\u4e49\uff1a typedef struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */ int refcount; void *ptr; } robj; \u5176\u4e2d\u7684LRU\u5f15\u8d77\u4e86\u6211\u7684\u6ce8\u610f\uff0c\u9042Google\u4e86\u4e00\u4e0b\uff0c\u53d1\u73b0\u4e86\u5982\u4e0b\u5185\u5bb9\uff1a - Cache replacement policies Redis Persistence https://redis.io/topics/persistence Redis Sentinel Documentation clients service discovery https://en.wikipedia.org/wiki/Service_discovery https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/ https://stackoverflow.com/questions/37148836/what-is-service-discovery-and-why-do-you-need-it redis pub/sub How to use Pub/sub with hiredis in C++? Add code example for pub/sub pub/sub sample redis source code c\u6ca1\u6709destructor\uff0c\u6211\u770bredis\u7684source code\u4e2d\u5b58\u5728\u7740\u5927\u91cf\u7684\u6307\u9488\uff0c\u90a3\u4e48\u5f53redis\u8fdb\u7a0b\u9000\u51fa\u6267\u884c\u7684\u65f6\u5019\uff0c\u662f\u5426\u9700\u8981\u6267\u884c\u6e05\u7406\u5de5\u4f5c\u5462\uff1f\u8fd8\u662f\u8bf4\u5b8c\u5168\u4f9d\u9760OS\u6765\u6267\u884c\u8fd9\u4e9b\u6e05\u7406\uff1b redis\u4f7f\u7528\u5f15\u7528\u8ba1\u6570\u6765\u5b9e\u73b0\u81ea\u52a8\u5185\u5b58\u7ba1\u7406 redis\u4fe1\u53f7\u5904\u7406 redis-server\u5411\u81ea\u5df1\u53d1\u9001\u4fe1\u53f7\u662f\u5426\u4f7f\u7528\u7684\u662fraise\uff1f \u53c2\u52a0APUE10.9 stream oriented \u51fa\u81ea\uff1a https://redis.io/topics/protocol Why TCP called stream oriented protocol? byte stream vs character stream consistent hashing https://redis.io/topics/cluster-tutorial https://en.wikipedia.org/wiki/Consistent_hashing redis data consistency https://www.cnblogs.com/bigben0123/p/9115597.html https://stackoverflow.com/questions/13681565/does-redis-support-strong-consistency http://antirez.com/news/36 https://docs.redislabs.com/latest/rs/concepts/data-access/consistency-durability/ https://quabase.sei.cmu.edu/mediawiki/index.php/Redis_Consistency_Features How Twitter Uses Redis To Scale - 105TB RAM, 39MM QPS, 10,000+ Instances http://highscalability.com/blog/2014/9/8/how-twitter-uses-redis-to-scale-105tb-ram-39mm-qps-10000-ins.html Learn Redis the hard way (in production) https://tech.trivago.com/2017/01/25/learn-redis-the-hard-way-in-production/","title":"TODO"},{"location":"TODO/#todo","text":"","title":"TODO"},{"location":"TODO/#cache#replacement#policies","text":"\u5728\u9605\u8bfbredis\u7684\u6e90\u4ee3\u7801\u7684\u65f6\u5019\uff0c \u53d1\u73b0\u4e86\u5982\u4e0b\u7684\u5b9a\u4e49\uff1a typedef struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */ int refcount; void *ptr; } robj; \u5176\u4e2d\u7684LRU\u5f15\u8d77\u4e86\u6211\u7684\u6ce8\u610f\uff0c\u9042Google\u4e86\u4e00\u4e0b\uff0c\u53d1\u73b0\u4e86\u5982\u4e0b\u5185\u5bb9\uff1a","title":"Cache replacement policies"},{"location":"TODO/#-#cache#replacement#policies","text":"","title":"- Cache replacement policies"},{"location":"TODO/#redis#persistence","text":"https://redis.io/topics/persistence","title":"Redis Persistence"},{"location":"TODO/#redis#sentinel#documentation","text":"","title":"Redis Sentinel Documentation"},{"location":"TODO/#clients#service#discovery","text":"https://en.wikipedia.org/wiki/Service_discovery https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/ https://stackoverflow.com/questions/37148836/what-is-service-discovery-and-why-do-you-need-it","title":"clients service discovery"},{"location":"TODO/#redis#pubsub","text":"How to use Pub/sub with hiredis in C++? Add code example for pub/sub pub/sub sample","title":"redis pub/sub"},{"location":"TODO/#redis#source#code","text":"c\u6ca1\u6709destructor\uff0c\u6211\u770bredis\u7684source code\u4e2d\u5b58\u5728\u7740\u5927\u91cf\u7684\u6307\u9488\uff0c\u90a3\u4e48\u5f53redis\u8fdb\u7a0b\u9000\u51fa\u6267\u884c\u7684\u65f6\u5019\uff0c\u662f\u5426\u9700\u8981\u6267\u884c\u6e05\u7406\u5de5\u4f5c\u5462\uff1f\u8fd8\u662f\u8bf4\u5b8c\u5168\u4f9d\u9760OS\u6765\u6267\u884c\u8fd9\u4e9b\u6e05\u7406\uff1b redis\u4f7f\u7528\u5f15\u7528\u8ba1\u6570\u6765\u5b9e\u73b0\u81ea\u52a8\u5185\u5b58\u7ba1\u7406","title":"redis source code"},{"location":"TODO/#redis","text":"redis-server\u5411\u81ea\u5df1\u53d1\u9001\u4fe1\u53f7\u662f\u5426\u4f7f\u7528\u7684\u662fraise\uff1f \u53c2\u52a0APUE10.9","title":"redis\u4fe1\u53f7\u5904\u7406"},{"location":"TODO/#stream#oriented","text":"\u51fa\u81ea\uff1a https://redis.io/topics/protocol Why TCP called stream oriented protocol?","title":"stream oriented"},{"location":"TODO/#byte#stream#vs#character#stream","text":"","title":"byte stream vs character stream"},{"location":"TODO/#consistent#hashing","text":"https://redis.io/topics/cluster-tutorial https://en.wikipedia.org/wiki/Consistent_hashing","title":"consistent hashing"},{"location":"TODO/#redis#data#consistency","text":"https://www.cnblogs.com/bigben0123/p/9115597.html https://stackoverflow.com/questions/13681565/does-redis-support-strong-consistency http://antirez.com/news/36 https://docs.redislabs.com/latest/rs/concepts/data-access/consistency-durability/ https://quabase.sei.cmu.edu/mediawiki/index.php/Redis_Consistency_Features","title":"redis data consistency"},{"location":"TODO/#how#twitter#uses#redis#to#scale#-#105tb#ram#39mm#qps#10000#instances","text":"http://highscalability.com/blog/2014/9/8/how-twitter-uses-redis-to-scale-105tb-ram-39mm-qps-10000-ins.html","title":"How Twitter Uses Redis To Scale - 105TB RAM, 39MM QPS, 10,000+ Instances"},{"location":"TODO/#learn#redis#the#hard#way#in#production","text":"https://tech.trivago.com/2017/01/25/learn-redis-the-hard-way-in-production/","title":"Learn Redis the hard way (in production)"},{"location":"Books/","text":"","title":"Introduction"},{"location":"Clients/Redis-plus-plus/Redis-plus-plus/","text":"redis-plus-plus \u5bf9 hiredis \u7684wrapper\uff0c\u5199\u7684\u975e\u5e38\u597d\u3002 Connection class Connection If the connection is broken, Redis reconnects to Redis server automatically. \u5982\u4f55\u5b9e\u73b0\u7684\u81ea\u52a8\u91cd\u8fde\uff1f Connection Failure Exception See errors.h for details Redis Sentinel NOTE: \u901a\u8fc7sentinel\u53ef\u4ee5\u83b7\u53d6master\u3001slave\u7684\u5730\u5740\uff0c\u7136\u540e\u53ef\u4ee5\u6307\u5b9a Redis \u8fde\u63a5\u5230\u5b83\u4eec\u3002 \u7c7b\u56fe `class Redis` has a `ConnectionPool _pool`","title":"Redis-plus-plus"},{"location":"Clients/Redis-plus-plus/Redis-plus-plus/#redis-plus-plus","text":"\u5bf9 hiredis \u7684wrapper\uff0c\u5199\u7684\u975e\u5e38\u597d\u3002","title":"redis-plus-plus"},{"location":"Clients/Redis-plus-plus/Redis-plus-plus/#connection","text":"","title":"Connection"},{"location":"Clients/Redis-plus-plus/Redis-plus-plus/#class#connection","text":"If the connection is broken, Redis reconnects to Redis server automatically.","title":"class Connection"},{"location":"Clients/Redis-plus-plus/Redis-plus-plus/#_1","text":"","title":"\u5982\u4f55\u5b9e\u73b0\u7684\u81ea\u52a8\u91cd\u8fde\uff1f"},{"location":"Clients/Redis-plus-plus/Redis-plus-plus/#connection#failure","text":"","title":"Connection Failure"},{"location":"Clients/Redis-plus-plus/Redis-plus-plus/#exception","text":"See errors.h for details","title":"Exception"},{"location":"Clients/Redis-plus-plus/Redis-plus-plus/#redis#sentinel","text":"NOTE: \u901a\u8fc7sentinel\u53ef\u4ee5\u83b7\u53d6master\u3001slave\u7684\u5730\u5740\uff0c\u7136\u540e\u53ef\u4ee5\u6307\u5b9a Redis \u8fde\u63a5\u5230\u5b83\u4eec\u3002","title":"Redis Sentinel"},{"location":"Clients/Redis-plus-plus/Redis-plus-plus/#_2","text":"`class Redis` has a `ConnectionPool _pool`","title":"\u7c7b\u56fe"},{"location":"Command/Commands/","text":"Commands client\u901a\u8fc7command\u6765\u64cd\u4f5credis server\uff0c\u672c\u6587\u5bf9redis\u7684command\u7684\u5b9e\u73b0\u8fdb\u884c\u5206\u6790\u3002 prototype of redis command function redis\u4e2d\u6240\u6709\u7528\u4e8e\u5904\u7406command\u7684\u51fd\u6570\u7684prototype\u5982\u4e0b\uff1a void Command(client *c); \u56e0\u4e3a\u5728\u5904\u7406command\u4e4b\u524d\uff0c readQueryFromClient \u51fd\u6570\u5df2\u7ecf\u5c06\u7528\u6237\u53d1\u9001\u8fc7\u6765\u7684command\u4fe1\u606f\u5199\u5165\u5230\u4e86client\u7684 argv \u6210\u5458\u53d8\u91cf\u4e2d\u3002 redis cluster command void clusterCommand(client *c) void dumpCommand(client *c) void restoreCommand(client *c) redis replication void syncCommand(client *c) void replconfCommand(client *c) redis config void configCommand(client *c)","title":"Commands"},{"location":"Command/Commands/#commands","text":"client\u901a\u8fc7command\u6765\u64cd\u4f5credis server\uff0c\u672c\u6587\u5bf9redis\u7684command\u7684\u5b9e\u73b0\u8fdb\u884c\u5206\u6790\u3002","title":"Commands"},{"location":"Command/Commands/#prototype#of#redis#command#function","text":"redis\u4e2d\u6240\u6709\u7528\u4e8e\u5904\u7406command\u7684\u51fd\u6570\u7684prototype\u5982\u4e0b\uff1a void Command(client *c); \u56e0\u4e3a\u5728\u5904\u7406command\u4e4b\u524d\uff0c readQueryFromClient \u51fd\u6570\u5df2\u7ecf\u5c06\u7528\u6237\u53d1\u9001\u8fc7\u6765\u7684command\u4fe1\u606f\u5199\u5165\u5230\u4e86client\u7684 argv \u6210\u5458\u53d8\u91cf\u4e2d\u3002","title":"prototype of redis command function"},{"location":"Command/Commands/#redis#cluster#command","text":"void clusterCommand(client *c) void dumpCommand(client *c) void restoreCommand(client *c)","title":"redis cluster command"},{"location":"Command/Commands/#redis#replication","text":"void syncCommand(client *c) void replconfCommand(client *c)","title":"redis replication"},{"location":"Command/Commands/#redis#config","text":"void configCommand(client *c)","title":"redis config"},{"location":"Data-structure/Dict/Dict-usage/","text":"redis\u8bbe\u8ba1\u4e0e\u5b9e\u73b0 \u7b2c\u56db\u7ae0 \u6570\u636e\u5e93 hash\u6570\u636e\u7c7b\u578b","title":"Dict-usage"},{"location":"Data-structure/Dict/Dict-usage/#redis","text":"","title":"redis\u8bbe\u8ba1\u4e0e\u5b9e\u73b0"},{"location":"Data-structure/Dict/Dict-usage/#_1","text":"\u6570\u636e\u5e93 hash\u6570\u636e\u7c7b\u578b","title":"\u7b2c\u56db\u7ae0"},{"location":"Data-structure/Dict/Dict/","text":"dict.h:struct dictEntry \u63cf\u8ff0\u952e\u503c\u5bf9 chain dict.h:struct dictht \u63cf\u8ff0hash table structure dict.h:dict \u63cf\u8ff0dict rehash","title":"Dict"},{"location":"Data-structure/Dict/Dict/#dicthstruct#dictentry","text":"\u63cf\u8ff0\u952e\u503c\u5bf9","title":"dict.h:struct dictEntry"},{"location":"Data-structure/Dict/Dict/#chain","text":"","title":"chain"},{"location":"Data-structure/Dict/Dict/#dicthstruct#dictht","text":"\u63cf\u8ff0hash table structure","title":"dict.h:struct dictht"},{"location":"Data-structure/Dict/Dict/#dicthdict","text":"\u63cf\u8ff0dict","title":"dict.h:dict"},{"location":"Data-structure/Dict/Dict/#rehash","text":"","title":"rehash"},{"location":"Data-structure/Dict/Dncremental-rehash/","text":"","title":"Dncremental-rehash"},{"location":"Data-structure/Generic-double-linked-list/Generic-double-linked-list/","text":"typedef struct listNode { struct listNode *prev; struct listNode *next; void *value; } listNode; \u8282\u70b9\u7684\u6570\u636e\u7c7b\u578b\u662fpointer\uff0c\u56e0\u4e3aredis\u4e2d\u7684\u6240\u6709\u7684\u6570\u636e\u90fd\u662f\u6765\u81ea\u4e8e\u7f51\u7edc\uff0c\u90fd\u662f\u4ece\u63a5\u6536\u5230\u7684\u6570\u636enew\u51fa\u4e00\u7247\u7a7a\u95f4\u7684\uff1b \u5728 networking.c \u4e2d\u6709\u5982\u4e0b\u51fd\u6570\uff1a /* This function links the client to the global linked list of clients. * unlinkClient() does the opposite, among other things. */ void linkClient(client *c) { listAddNodeTail(server.clients,c); /* Note that we remember the linked list node where the client is stored, * this way removing the client in unlinkClient() will not require * a linear scan, but just a constant time operation. */ c->client_list_node = listLast(server.clients); uint64_t id = htonu64(c->id); raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL); } listAddNodeTail \u51fd\u6570\u7684\u539f\u578b\u5982\u4e0b\uff1a list *listAddNodeTail(list *list, void *value) \u663e\u7136\u5728 linkClient \u51fd\u6570\u4e2d\uff0c\u6d89\u53ca\u4e86\u4ece client * \u5230 void * \u7c7b\u578b\u7684\u8f6c\u6362","title":"Generic-double-linked-list"},{"location":"Data-structure/Rax/","text":"rax redis\u7684rax\u5b9e\u73b0\u5176\u5b9e\u662f\u5373\u652f\u6301trie\u53c8\u652f\u6301radix tree\u7684\uff1b\u8ba4\u77e5\u5230\u8fd9\u4e00\u70b9\uff0c\u6211\u662f\u5148\u901a\u8fc7\u9605\u8bfb\u4e86trie\u7684\u5b9e\u73b0\u540e\uff0c\u518d\u9605\u8bfbredis rax\u7684\u5b9e\u73b0\u624d\u53d1\u73b0\u7684\u8fd9\u4e2a\u95ee\u9898\uff0c\u4ee5\u4e0b\u662ftrie\u7684\u4e24\u79cd\u5b9e\u73b0\uff1a python trie\uff1a https://github.com/dengking/TheAlgorithms-Python/tree/master/data_structures/trie c trie\uff1a https://github.com/dengking/TheAlgorithms-C/tree/master/data_structures/trie python trie\u4e2d\uff0cnode\u7684\u5b9a\u4e49\u662f\u5982\u4e0b\u7684\uff1a class TrieNode : def __init__ ( self ): self . nodes = dict () # Mapping from char to TrieNode self . is_leaf = False \u5b83\u901a\u8fc7\u4f7f\u7528 dict \u6765\u5b9e\u73b0\u8282\u70b9\u4e4b\u95f4\u7684\u5173\u8054\uff0c\u5176\u5b9e\u53ef\u4ee5\u8ba4\u4e3a dict \u6240\u4fdd\u5b58\u7684\u662fedge\uff0c dict \u7684key\u5c31\u662fedge\u7684label\uff1b radish rax\u5728\u652f\u6301trie\u7684\u65f6\u5019\uff0c\u5176\u5b9e\u4f7f\u7528\u7684\u5c31\u662f\u7c7b\u4f3c\u4e8e\u4e0a\u8ff0\u7684\u5b9e\u73b0\u65b9\u5f0f\uff0c\u4ee5\u4e0b\u662f\u5b83\u7684\u6587\u6863\u4e2d\u7ed9\u51fa\u7684\uff1a /* Data layout is as follows: * * If node is not compressed we have 'size' bytes, one for each children * character, and 'size' raxNode pointers, point to each child node. * Note how the character is not stored in the children but in the * edge of the parents: * * [header iscompr=0][abc][a-ptr][b-ptr][c-ptr](value-ptr?) [abc][a-ptr][b-ptr][c-ptr] \u5176\u5b9e\u5c31\u76f8\u5f53\u4e8e\u4e00\u4e2adict","title":"Introduction"},{"location":"Data-structure/Rax/#rax","text":"redis\u7684rax\u5b9e\u73b0\u5176\u5b9e\u662f\u5373\u652f\u6301trie\u53c8\u652f\u6301radix tree\u7684\uff1b\u8ba4\u77e5\u5230\u8fd9\u4e00\u70b9\uff0c\u6211\u662f\u5148\u901a\u8fc7\u9605\u8bfb\u4e86trie\u7684\u5b9e\u73b0\u540e\uff0c\u518d\u9605\u8bfbredis rax\u7684\u5b9e\u73b0\u624d\u53d1\u73b0\u7684\u8fd9\u4e2a\u95ee\u9898\uff0c\u4ee5\u4e0b\u662ftrie\u7684\u4e24\u79cd\u5b9e\u73b0\uff1a python trie\uff1a https://github.com/dengking/TheAlgorithms-Python/tree/master/data_structures/trie c trie\uff1a https://github.com/dengking/TheAlgorithms-C/tree/master/data_structures/trie python trie\u4e2d\uff0cnode\u7684\u5b9a\u4e49\u662f\u5982\u4e0b\u7684\uff1a class TrieNode : def __init__ ( self ): self . nodes = dict () # Mapping from char to TrieNode self . is_leaf = False \u5b83\u901a\u8fc7\u4f7f\u7528 dict \u6765\u5b9e\u73b0\u8282\u70b9\u4e4b\u95f4\u7684\u5173\u8054\uff0c\u5176\u5b9e\u53ef\u4ee5\u8ba4\u4e3a dict \u6240\u4fdd\u5b58\u7684\u662fedge\uff0c dict \u7684key\u5c31\u662fedge\u7684label\uff1b radish rax\u5728\u652f\u6301trie\u7684\u65f6\u5019\uff0c\u5176\u5b9e\u4f7f\u7528\u7684\u5c31\u662f\u7c7b\u4f3c\u4e8e\u4e0a\u8ff0\u7684\u5b9e\u73b0\u65b9\u5f0f\uff0c\u4ee5\u4e0b\u662f\u5b83\u7684\u6587\u6863\u4e2d\u7ed9\u51fa\u7684\uff1a /* Data layout is as follows: * * If node is not compressed we have 'size' bytes, one for each children * character, and 'size' raxNode pointers, point to each child node. * Note how the character is not stored in the children but in the * edge of the parents: * * [header iscompr=0][abc][a-ptr][b-ptr][c-ptr](value-ptr?) [abc][a-ptr][b-ptr][c-ptr] \u5176\u5b9e\u5c31\u76f8\u5f53\u4e8e\u4e00\u4e2adict","title":"rax"},{"location":"Event-library/","text":"","title":"Introduction"},{"location":"Redis-cli/Redis-cli/","text":"redis-cli redis-cli, the Redis command line interface redis-cli is the Redis command line interface, a simple program that allows to send commands to Redis, and read the replies sent by the server, directly from the terminal. It has two main modes: an interactive mode where there is a REPL ( Read Eval Print Loop ) where the user types commands and get replies; and another mode where the command is sent as arguments of redis-cli , executed, and printed on the standard output. NOTE: \u7b2c\u4e8c\u4e2amode\u6240\u6307\u7684\u662f\u5982\u4e0b\u8fd9\u79cd\u4f7f\u7528\u65b9\u5f0f\uff1a redis-cli KEYS \"prefix:*\" | xargs redis-cli DEL In interactive mode, redis-cli has basic line editing capabilities to provide a good typing experience. However redis-cli is not just that. There are options you can use to launch the program in order to put it into special modes, so that redis-cli can definitely do more complex tasks, like simulate a slave and print the replication stream it receives from the master , check the latency of a Redis server and show statistics or even an ASCII-art spectrogram of latency samples and frequencies, and many other things. This guide will cover the different aspects of redis-cli , starting from the simplest and ending with the more advanced ones. SUMMARY : redis-cli\u4e0d\u4ec5\u4ec5\u53ea\u6709\u4e0a\u8ff0\u7684mode\uff0c\u8fd8\u6709\u5176\u4ed6\u7684mode\uff0c\u53c2\u89c1 Special modes of operation If you are going to use Redis extensively, or if you already do, chances are you happen to use redis-cli a lot. Spending some time to familiarize with it is likely a very good idea, you'll see that you'll work more effectively with Redis once you know all the tricks of its command line interface. Command line usage Host, port, password and database Getting input from other programs Continuously run the same command Mass insertion of data using redis-cli CSV output Running Lua scripts Interactive mode Handling connections and reconnections Editing, history and completion Running the same command N times Showing help about Redis commands Special modes of operation So far we saw two main modes of redis-cli . Command line execution of Redis commands. Interactive \"REPL-like\" usage. However the CLI performs other auxiliary tasks related to Redis that are explained in the next sections: Monitoring tool to show continuous stats about a Redis server. Scanning a Redis database for very large keys. Key space scanner with pattern matching. Acting as a Pub/Sub client to subscribe to channels. Monitoring the commands executed into a Redis instance. Checking the latency of a Redis server in different ways. Checking the scheduler latency of the local computer. Transferring RDB backups from a remote Redis server locally. Acting as a Redis slave for showing what a slave receives. Simulating LRU workloads for showing stats about keys hits. A client for the Lua debugger. \u5b9e\u73b0\u5206\u6790 \u201cinteractive mode \u201d\u7684\u5165\u53e3\u51fd\u6570\u662f\uff1a repl \"Command line execution of Redis commands\"\u7684 \"Running Lua scripts\"\u7684\u5165\u53e3\u51fd\u6570\u662f: evalMode redis\u6240\u652f\u6301\u7684\u6240\u6709\u7684command\u90fd\u5728\"help.h\"\u4e2d\u5b9a\u4e49. \u5982\u4f55\u7ec4\u7ec7\u6240\u6709\u7684command\uff1f \u5982\u4f55\u7ec4\u7ec7\u6240\u6709\u7684command\u548ccommand\u5bf9\u5e94\u7684\u6267\u884c\u51fd\u6570\uff1f","title":"Redis-cli"},{"location":"Redis-cli/Redis-cli/#redis-cli","text":"","title":"redis-cli"},{"location":"Redis-cli/Redis-cli/#redis-cli#the#redis#command#line#interface","text":"redis-cli is the Redis command line interface, a simple program that allows to send commands to Redis, and read the replies sent by the server, directly from the terminal. It has two main modes: an interactive mode where there is a REPL ( Read Eval Print Loop ) where the user types commands and get replies; and another mode where the command is sent as arguments of redis-cli , executed, and printed on the standard output. NOTE: \u7b2c\u4e8c\u4e2amode\u6240\u6307\u7684\u662f\u5982\u4e0b\u8fd9\u79cd\u4f7f\u7528\u65b9\u5f0f\uff1a redis-cli KEYS \"prefix:*\" | xargs redis-cli DEL In interactive mode, redis-cli has basic line editing capabilities to provide a good typing experience. However redis-cli is not just that. There are options you can use to launch the program in order to put it into special modes, so that redis-cli can definitely do more complex tasks, like simulate a slave and print the replication stream it receives from the master , check the latency of a Redis server and show statistics or even an ASCII-art spectrogram of latency samples and frequencies, and many other things. This guide will cover the different aspects of redis-cli , starting from the simplest and ending with the more advanced ones. SUMMARY : redis-cli\u4e0d\u4ec5\u4ec5\u53ea\u6709\u4e0a\u8ff0\u7684mode\uff0c\u8fd8\u6709\u5176\u4ed6\u7684mode\uff0c\u53c2\u89c1 Special modes of operation If you are going to use Redis extensively, or if you already do, chances are you happen to use redis-cli a lot. Spending some time to familiarize with it is likely a very good idea, you'll see that you'll work more effectively with Redis once you know all the tricks of its command line interface.","title":"redis-cli, the Redis command line interface"},{"location":"Redis-cli/Redis-cli/#command#line#usage","text":"","title":"Command line usage"},{"location":"Redis-cli/Redis-cli/#host#port#password#and#database","text":"","title":"Host, port, password and database"},{"location":"Redis-cli/Redis-cli/#getting#input#from#other#programs","text":"","title":"Getting input from other programs"},{"location":"Redis-cli/Redis-cli/#continuously#run#the#same#command","text":"","title":"Continuously run the same command"},{"location":"Redis-cli/Redis-cli/#mass#insertion#of#data#using#redis-cli","text":"","title":"Mass insertion of data using redis-cli"},{"location":"Redis-cli/Redis-cli/#csv#output","text":"","title":"CSV output"},{"location":"Redis-cli/Redis-cli/#running#lua#scripts","text":"","title":"Running Lua scripts"},{"location":"Redis-cli/Redis-cli/#interactive#mode","text":"","title":"Interactive mode"},{"location":"Redis-cli/Redis-cli/#handling#connections#and#reconnections","text":"","title":"Handling connections and reconnections"},{"location":"Redis-cli/Redis-cli/#editing#history#and#completion","text":"","title":"Editing, history and completion"},{"location":"Redis-cli/Redis-cli/#running#the#same#command#n#times","text":"","title":"Running the same command N times"},{"location":"Redis-cli/Redis-cli/#showing#help#about#redis#commands","text":"","title":"Showing help about Redis commands"},{"location":"Redis-cli/Redis-cli/#special#modes#of#operation","text":"So far we saw two main modes of redis-cli . Command line execution of Redis commands. Interactive \"REPL-like\" usage. However the CLI performs other auxiliary tasks related to Redis that are explained in the next sections: Monitoring tool to show continuous stats about a Redis server. Scanning a Redis database for very large keys. Key space scanner with pattern matching. Acting as a Pub/Sub client to subscribe to channels. Monitoring the commands executed into a Redis instance. Checking the latency of a Redis server in different ways. Checking the scheduler latency of the local computer. Transferring RDB backups from a remote Redis server locally. Acting as a Redis slave for showing what a slave receives. Simulating LRU workloads for showing stats about keys hits. A client for the Lua debugger.","title":"Special modes of operation"},{"location":"Redis-cli/Redis-cli/#_1","text":"\u201cinteractive mode \u201d\u7684\u5165\u53e3\u51fd\u6570\u662f\uff1a repl \"Command line execution of Redis commands\"\u7684 \"Running Lua scripts\"\u7684\u5165\u53e3\u51fd\u6570\u662f: evalMode redis\u6240\u652f\u6301\u7684\u6240\u6709\u7684command\u90fd\u5728\"help.h\"\u4e2d\u5b9a\u4e49.","title":"\u5b9e\u73b0\u5206\u6790"},{"location":"Redis-cli/Redis-cli/#command","text":"\u5982\u4f55\u7ec4\u7ec7\u6240\u6709\u7684command\u548ccommand\u5bf9\u5e94\u7684\u6267\u884c\u51fd\u6570\uff1f","title":"\u5982\u4f55\u7ec4\u7ec7\u6240\u6709\u7684command\uff1f"},{"location":"Redis-cli/linenoise/linenoise/","text":"linenoise redis-cli\u7684\u5b9e\u73b0\u4f9d\u8d56\u4e8elinenoise\uff0c\u9664\u6b64\u4e4b\u5916\uff0c\u4f7f\u7528linenoise\u6211\u4eec\u53ef\u4ee5\u6784\u5efa\u81ea\u5df1\u7684server\u7684command line interface\u3002 linenoise A small self-contained alternative to readline and libedit. The API The library returns a buffer with the line composed by the user, or NULL on end of file or when there is an out of memory condition. NOTE: \u8fd9\u6bb5\u8bdd\u600e\u4e48\u7406\u89e3\uff1f","title":"linenoise"},{"location":"Redis-cli/linenoise/linenoise/#linenoise","text":"redis-cli\u7684\u5b9e\u73b0\u4f9d\u8d56\u4e8elinenoise\uff0c\u9664\u6b64\u4e4b\u5916\uff0c\u4f7f\u7528linenoise\u6211\u4eec\u53ef\u4ee5\u6784\u5efa\u81ea\u5df1\u7684server\u7684command line interface\u3002","title":"linenoise"},{"location":"Redis-cli/linenoise/linenoise/#linenoise_1","text":"A small self-contained alternative to readline and libedit.","title":"linenoise"},{"location":"Redis-cli/linenoise/linenoise/#the#api","text":"The library returns a buffer with the line composed by the user, or NULL on end of file or when there is an out of memory condition. NOTE: \u8fd9\u6bb5\u8bdd\u600e\u4e48\u7406\u89e3\uff1f","title":"The API"},{"location":"Sentinel/Redis-Sentinel/","text":"Redis sentinel \u5b98\u65b9\u6587\u6863 Redis Sentinel Documentation Redis Sentinel also provides other collateral\uff08\u9644\u5c5e\u7684\uff09 tasks such as monitoring , notifications and acts as a configuration provider for clients. This is the full list of Sentinel capabilities at a macroscopical\uff08\u5b8f\u89c2\u7684\uff09 level (i.e. the big picture ): Monitoring . Sentinel constantly checks if your master and slave instances are working as expected. Notification . Sentinel can notify the system administrator , another computer programs, via an API, that something is wrong with one of the monitored Redis instances. Automatic failover . If a master is not working as expected, Sentinel can start a failover process where a slave is promoted to master, the other additional slaves are reconfigured to use the new master, and the applications using the Redis server informed about the new address to use when connecting. \u81ea\u52a8\u6545\u969c\u8f6c\u79fb\u3002 \u5982\u679c\u4e3b\u670d\u52a1\u5668\u672a\u6309\u9884\u671f\u5de5\u4f5c\uff0cSentinel\u53ef\u4ee5\u542f\u52a8\u6545\u969c\u8f6c\u79fb\u8fc7\u7a0b\uff0c\u5176\u4e2d\u4ece\u670d\u52a1\u5668\u5347\u7ea7\u4e3a\u4e3b\u670d\u52a1\u5668\uff0c\u5176\u4ed6\u5176\u4ed6\u670d\u52a1\u5668\u91cd\u65b0\u914d\u7f6e\u4e3a\u4f7f\u7528\u65b0\u4e3b\u670d\u52a1\u5668\uff0c\u5e76\u4e14\u4f7f\u7528Redis\u670d\u52a1\u5668\u7684\u5e94\u7528\u7a0b\u5e8f\u901a\u77e5\u6709\u5173\u65b0\u670d\u52a1\u5668\u7684\u5730\u5740\u3002\u8fde\u63a5\u3002 Configuration provider . Sentinel acts as a source of authority for clients service discovery : clients connect to Sentinels in order to ask for the address of the current Redis master responsible for a given service. If a failover occurs, Sentinels will report the new address. Distributed nature of Sentinel Redis Sentinel is a distributed system: Sentinel itself is designed to run in a configuration where there are multiple Sentinel processes cooperating together. The advantage of having multiple Sentinel processes cooperating are the following: Failure detection is performed when multiple Sentinels agree about the fact a given master is no longer available. This lowers the probability of false positives . Sentinel works even if not all the Sentinel processes are working, making the system robust against failures. There is no fun in having a fail over system which is itself a single point of failure, after all. The sum of Sentinels, Redis instances (masters and slaves) and clients connecting to Sentinel and Redis, are also a larger distributed system with specific properties. In this document concepts will be introduced gradually starting from basic information needed in order to understand the basic properties of Sentinel, to more complex information (that are optional) in order to understand how exactly Sentinel works. Quick Start Obtaining Sentinel The current version of Sentinel is called Sentinel 2 . It is a rewrite of the initial Sentinel implementation using stronger and simpler to predict algorithms (that are explained in this documentation). A stable release of Redis Sentinel is shipped since Redis 2.8. New developments are performed in the unstable branch, and new features sometimes are back ported into the latest stable branch as soon as they are considered to be stable. Redis Sentinel version 1, shipped with Redis 2.6, is deprecated and should not be used. Running Sentinel If you are using the redis-sentinel executable (or if you have a symbolic link with that name to the redis-server executable) you can run Sentinel with the following command line: redis-sentinel /path/to/sentinel.conf Otherwise you can use directly the redis-server executable starting it in Sentinel mode : redis-server /path/to/sentinel.conf --sentinel Both ways work the same. However it is mandatory to use a configuration file when running Sentinel , as this file will be used by the system in order to save the current state that will be reloaded in case of restarts. Sentinel will simply refuse to start if no configuration file is given or if the configuration file path is not writable. Sentinels by default run listening for connections to TCP port 26379 , so for Sentinels to work, port 26379 of your servers must be open to receive connections from the IP addresses of the other Sentinel instances . Otherwise Sentinels can't talk and can't agree about what to do, so failover will never be performed. Fundamental things to know about Sentinel before deploying You need at least three Sentinel instances for a robust deployment. The three Sentinel instances should be placed into computers or virtual machines that are believed to fail in an independent way. So for example different physical servers or Virtual Machines executed on different availability zones. Sentinel + Redis distributed system does not guarantee that acknowledged writes are retained(\u4fdd\u6301) during failures, since Redis uses asynchronous replication . However there are ways to deploy Sentinel that make the window to lose writes limited to certain moments, while there are other less secure ways to deploy it. You need Sentinel support in your clients. Popular client libraries have Sentinel support, but not all. There is no HA setup which is safe if you don't test from time to time in development environments, or even better if you can, in production environments, if they work. You may have a misconfiguration that will become apparent only when it's too late (at 3am when your master stops working). Sentinel, Docker, or other forms of Network Address Translation or Port Mapping should be mixed with care : Docker performs port remapping, breaking Sentinel auto discovery of other Sentinel processes and the list of slaves for a master. Check the section about Sentinel and Docker later in this document for more information. Configuring Sentinel The Redis source distribution contains a file called sentinel.conf that is a self-documented example configuration file you can use to configure Sentinel, however a typical minimal configuration file looks like the following: sentinel monitor mymaster 127.0.0.1 6379 2 sentinel down-after-milliseconds mymaster 60000 sentinel failover-timeout mymaster 180000 sentinel parallel-syncs mymaster 1 sentinel monitor resque 192.168.1.3 6380 4 sentinel down-after-milliseconds resque 10000 sentinel failover-timeout resque 180000 sentinel parallel-syncs resque 5 You only need to specify the masters to monitor, giving to each separated master (that may have any number of slaves) a different name . There is no need to specify slaves , which are auto-discovered . Sentinel will update the configuration automatically with additional information about slaves (in order to retain the information in case of restart). The configuration is also rewritten every time a slave is promoted to master during a failover and every time a new Sentinel is discovered. The example configuration above, basically monitor two sets of Redis instances , each composed of a master and an undefined number of slaves. One set of instances is called mymaster , and the other resque . The meaning of the arguments of sentinel monitor statements is the following: sentinel monitor <master-group-name> <ip> <port> <quorum> For the sake of clarity, let's check line by line what the configuration options mean: The first line is used to tell Redis to monitor a master called mymaster , that is at address 127.0.0.1 and port 6379, with a quorum of 2. Everything is pretty obvious but the quorum argument: The quorum is the number of Sentinels that need to agree about the fact the master is not reachable, in order for really mark the slave as failing, and eventually start a fail over procedure if possible. However the quorum is only used to detect the failure . In order to actually perform a failover, one of the Sentinels need to be elected leader for the failover and be authorized to proceed. This only happens with the vote of the majority of the Sentinel processes . So for example if you have 5 Sentinel processes, and the quorum for a given master set to the value of 2, this is what happens: If two Sentinels agree at the same time about the master being unreachable, one of the two will try to start a failover. If there are at least a total of three Sentinels reachable , the failover will be authorized and will actually start. In practical terms this means during failures Sentinel never starts a failover if the majority of Sentinel processes are unable to talk (aka no failover in the minority partition). \u5b9e\u9645\u4e0a\uff0c\u8fd9\u610f\u5473\u7740\u5728\u6545\u969c\u671f\u95f4\uff0c\u5982\u679c\u5927\u591a\u6570Sentinel\u8fdb\u7a0b\u65e0\u6cd5\u901a\u8bdd\uff08\u5728\u5c11\u6570\u5206\u533a\u4e2d\u4e5f\u6ca1\u6709\u6545\u969c\u8f6c\u79fb\uff09\uff0cSentinel\u6c38\u8fdc\u4e0d\u4f1a\u542f\u52a8\u6545\u969c\u8f6c\u79fb\u3002 Other Sentinel options The other options are almost always in the form: sentinel <option_name> <master_name> <option_value> And are used for the following purposes: down-after-milliseconds is the time in milliseconds an instance should not be reachable (either does not reply to our PINGs or it is replying with an error) for a Sentinel starting to think it is down. parallel-syncs sets the number of slaves that can be reconfigured to use the new master after a failover at the same time. The lower the number, the more time it will take for the failover process to complete, however if the slaves are configured to serve old data, you may not want all the slaves to re-synchronize with the master at the same time. While the replication process is mostly non blocking for a slave, there is a moment when it stops to load the bulk data from the master. You may want to make sure only one slave at a time is not reachable by setting this option to the value of 1. parallel-syncs\u8bbe\u7f6e\u53ef\u5728\u540c\u4e00\u6545\u969c\u8f6c\u79fb\u540e\u91cd\u65b0\u914d\u7f6e\u4e3a\u4f7f\u7528\u65b0\u4e3b\u670d\u52a1\u5668\u7684\u4ece\u670d\u52a1\u5668\u6570\u3002 \u6570\u5b57\u8d8a\u5c0f\uff0c\u6545\u969c\u8f6c\u79fb\u8fc7\u7a0b\u5b8c\u6210\u6240\u9700\u7684\u65f6\u95f4\u5c31\u8d8a\u591a\uff0c\u4f46\u662f\u5982\u679c\u4ece\u5c5e\u670d\u52a1\u5668\u914d\u7f6e\u4e3a\u63d0\u4f9b\u65e7\u6570\u636e\uff0c\u5219\u53ef\u80fd\u4e0d\u5e0c\u671b\u6240\u6709\u4ece\u5c5e\u670d\u52a1\u5668\u540c\u65f6\u4e0e\u4e3b\u670d\u52a1\u5668\u91cd\u65b0\u540c\u6b65\u3002 \u867d\u7136\u590d\u5236\u8fc7\u7a0b\u5bf9\u4e8e\u4ece\u5c5e\u8bbe\u5907\u5927\u90e8\u5206\u662f\u975e\u963b\u585e\u7684\uff0c\u4f46\u662f\u6709\u4e00\u6bb5\u65f6\u95f4\u5b83\u505c\u6b62\u4ece\u4e3b\u8bbe\u5907\u52a0\u8f7d\u6279\u91cf\u6570\u636e\u3002 \u60a8\u53ef\u80fd\u5e0c\u671b\u901a\u8fc7\u5c06\u6b64\u9009\u9879\u8bbe\u7f6e\u4e3a\u503c1\u6765\u786e\u4fdd\u4e00\u6b21\u53ea\u80fd\u8bbf\u95ee\u4e00\u4e2a\u4ece\u7ad9\u3002 Additional options are described in the rest of this document and documented in the example sentinel.conf file shipped with the Redis distribution. All the configuration parameters can be modified at runtime using the SENTINEL SET command. See the Reconfiguring Sentinel at runtime section for more information. Example Sentinel deployments Now that you know the basic information about Sentinel, you may wonder where you should place your Sentinel processes , how much Sentinel processes you need and so forth. This section shows a few example deployments. We use ASCII art in order to show you configuration examples in a graphical format, this is what the different symbols means: +--------------------+ | This is a computer | | or VM that fails | | independently. We | | call it a \"box\" | +--------------------+ We write inside the boxes what they are running: +-------------------+ | Redis master M1 | | Redis Sentinel S1 | +-------------------+ Different boxes are connected by lines, to show that they are able to talk: +-------------+ +-------------+ | Sentinel S1 |---------------| Sentinel S2 | +-------------+ +-------------+ Network partitions are shown as interrupted lines using slashes: +-------------+ +-------------+ | Sentinel S1 |------ // ------| Sentinel S2 | +-------------+ +-------------+ Also note that: Masters are called M1, M2, M3, ..., Mn. Slaves are called R1, R2, R3, ..., Rn (R stands for replica ). Sentinels are called S1, S2, S3, ..., Sn. Clients are called C1, C2, C3, ..., Cn. When an instance changes role because of Sentinel actions, we put it inside square brackets, so [M1] means an instance that is now a master because of Sentinel intervention. Example 1: just two Sentinels, DON'T DO THIS +----+ +----+ | M1 |---------| R1 | | S1 | | S2 | +----+ +----+ Configuration: quorum = 1 In this setup, if the master M1 fails, R1 will be promoted since the two Sentinels can reach agreement about the failure (obviously with quorum set to 1) and can also authorize\uff08\u6279\u51c6\uff09 a failover because the majority is two. So apparently it could superficially work, however check the next points to see why this setup is broken. If the box where M1 is running stops working, also S1 stops working. The Sentinel running in the other box S2 will not be able to authorize a failover, so the system will become not available. Note that a majority is needed in order to order different failovers, and later propagate the latest configuration to all the Sentinels . Also note that the ability to failover in a single side of the above setup, without any agreement, would be very dangerous: +----+ +------+ | M1 |----//-----| [M1] | | S1 | | S2 | +----+ +------+ In the above configuration we created two masters (assuming S2 could failover without authorization) in a perfectly symmetrical way. Clients may write indefinitely to both sides, and there is no way to understand when the partition heals what configuration is the right one, in order to prevent a permanent split brain condition . \u5728\u4e0a\u9762\u7684\u914d\u7f6e\u4e2d\uff0c\u6211\u4eec\u4ee5\u5b8c\u5168\u5bf9\u79f0\u7684\u65b9\u5f0f\u521b\u5efa\u4e86\u4e24\u4e2a\u4e3b\u670d\u52a1\u5668\uff08\u5047\u8bbeS2\u53ef\u4ee5\u5728\u672a\u7ecf\u6388\u6743\u7684\u60c5\u51b5\u4e0b\u8fdb\u884c\u6545\u969c\u8f6c\u79fb\uff09\u3002 \u5ba2\u6237\u7aef\u53ef\u4ee5\u65e0\u9650\u671f\u5730\u5411\u53cc\u65b9\u5199\u5165\uff0c\u5e76\u4e14\u65e0\u6cd5\u7406\u89e3\u5206\u533a\u4f55\u65f6\u6062\u590d\u6b63\u786e\u7684\u914d\u7f6e\uff0c\u4ee5\u9632\u6b62\u6c38\u4e45\u6027\u7684\u88c2\u8111\u60c5\u51b5\u3002 So please deploy at least three Sentinels in three different boxes always. Example 2: basic setup with three boxes This is a very simple setup, that has the advantage to be simple to tune for additional safety. It is based on three boxes, each box running both a Redis process and a Sentinel process. +----+ | M1 | | S1 | +----+ | +----+ | +----+ | R2 |----+----| R3 | | S2 | | S3 | +----+ +----+ Configuration: quorum = 2 If the master M1 fails, S2 and S3 will agree about the failure and will be able to authorize a failover, making clients able to continue. In every Sentinel setup, being Redis asynchronously replicated, there is always the risk of losing some write because a given acknowledged write may not be able to reach the slave which is promoted to master. However in the above setup there is an higher risk due to clients partitioned away with an old master, like in the following picture: +----+ | M1 | | S1 | <- C1 (writes will be lost) +----+ | / / +------+ | +----+ | [M2] |----+----| R3 | | S2 | | S3 | +------+ +----+ A quick tutorial Asking Sentinel about the state of a master Obtaining the address of the current master Testing the failover Sentinel API Sentinel commands Reconfiguring Sentinel at Runtime Adding or removing Sentinels Removing the old master or unreachable slaves Pub/Sub Messages Handling of -BUSY state Slaves priority Sentinel and Redis authentication Configuring Sentinel instances with authentication More advanced concepts In the following sections we'll cover a few details about how Sentinel work, without to resorting to implementation details and algorithms that will be covered in the final part of this document. SDOWN and ODOWN failure state Sentinels and Slaves auto discovery Sentinel reconfiguration of instances outside the failover procedure Slave selection and priority Algorithms and internals In the following sections we will explore the details of Sentinel behavior. It is not strictly needed for users to be aware of all the details, but a deep understanding of Sentinel may help to deploy and operate Sentinel in a more effective way. Quorum","title":"Redis-Sentinel"},{"location":"Sentinel/Redis-Sentinel/#redis#sentinel","text":"","title":"Redis sentinel"},{"location":"Sentinel/Redis-Sentinel/#redis#sentinel#documentation","text":"Redis Sentinel also provides other collateral\uff08\u9644\u5c5e\u7684\uff09 tasks such as monitoring , notifications and acts as a configuration provider for clients. This is the full list of Sentinel capabilities at a macroscopical\uff08\u5b8f\u89c2\u7684\uff09 level (i.e. the big picture ): Monitoring . Sentinel constantly checks if your master and slave instances are working as expected. Notification . Sentinel can notify the system administrator , another computer programs, via an API, that something is wrong with one of the monitored Redis instances. Automatic failover . If a master is not working as expected, Sentinel can start a failover process where a slave is promoted to master, the other additional slaves are reconfigured to use the new master, and the applications using the Redis server informed about the new address to use when connecting. \u81ea\u52a8\u6545\u969c\u8f6c\u79fb\u3002 \u5982\u679c\u4e3b\u670d\u52a1\u5668\u672a\u6309\u9884\u671f\u5de5\u4f5c\uff0cSentinel\u53ef\u4ee5\u542f\u52a8\u6545\u969c\u8f6c\u79fb\u8fc7\u7a0b\uff0c\u5176\u4e2d\u4ece\u670d\u52a1\u5668\u5347\u7ea7\u4e3a\u4e3b\u670d\u52a1\u5668\uff0c\u5176\u4ed6\u5176\u4ed6\u670d\u52a1\u5668\u91cd\u65b0\u914d\u7f6e\u4e3a\u4f7f\u7528\u65b0\u4e3b\u670d\u52a1\u5668\uff0c\u5e76\u4e14\u4f7f\u7528Redis\u670d\u52a1\u5668\u7684\u5e94\u7528\u7a0b\u5e8f\u901a\u77e5\u6709\u5173\u65b0\u670d\u52a1\u5668\u7684\u5730\u5740\u3002\u8fde\u63a5\u3002 Configuration provider . Sentinel acts as a source of authority for clients service discovery : clients connect to Sentinels in order to ask for the address of the current Redis master responsible for a given service. If a failover occurs, Sentinels will report the new address.","title":"\u5b98\u65b9\u6587\u6863Redis Sentinel Documentation"},{"location":"Sentinel/Redis-Sentinel/#distributed#nature#of#sentinel","text":"Redis Sentinel is a distributed system: Sentinel itself is designed to run in a configuration where there are multiple Sentinel processes cooperating together. The advantage of having multiple Sentinel processes cooperating are the following: Failure detection is performed when multiple Sentinels agree about the fact a given master is no longer available. This lowers the probability of false positives . Sentinel works even if not all the Sentinel processes are working, making the system robust against failures. There is no fun in having a fail over system which is itself a single point of failure, after all. The sum of Sentinels, Redis instances (masters and slaves) and clients connecting to Sentinel and Redis, are also a larger distributed system with specific properties. In this document concepts will be introduced gradually starting from basic information needed in order to understand the basic properties of Sentinel, to more complex information (that are optional) in order to understand how exactly Sentinel works.","title":"Distributed nature of Sentinel"},{"location":"Sentinel/Redis-Sentinel/#quick#start","text":"","title":"Quick Start"},{"location":"Sentinel/Redis-Sentinel/#obtaining#sentinel","text":"The current version of Sentinel is called Sentinel 2 . It is a rewrite of the initial Sentinel implementation using stronger and simpler to predict algorithms (that are explained in this documentation). A stable release of Redis Sentinel is shipped since Redis 2.8. New developments are performed in the unstable branch, and new features sometimes are back ported into the latest stable branch as soon as they are considered to be stable. Redis Sentinel version 1, shipped with Redis 2.6, is deprecated and should not be used.","title":"Obtaining Sentinel"},{"location":"Sentinel/Redis-Sentinel/#running#sentinel","text":"If you are using the redis-sentinel executable (or if you have a symbolic link with that name to the redis-server executable) you can run Sentinel with the following command line: redis-sentinel /path/to/sentinel.conf Otherwise you can use directly the redis-server executable starting it in Sentinel mode : redis-server /path/to/sentinel.conf --sentinel Both ways work the same. However it is mandatory to use a configuration file when running Sentinel , as this file will be used by the system in order to save the current state that will be reloaded in case of restarts. Sentinel will simply refuse to start if no configuration file is given or if the configuration file path is not writable. Sentinels by default run listening for connections to TCP port 26379 , so for Sentinels to work, port 26379 of your servers must be open to receive connections from the IP addresses of the other Sentinel instances . Otherwise Sentinels can't talk and can't agree about what to do, so failover will never be performed.","title":"Running Sentinel"},{"location":"Sentinel/Redis-Sentinel/#fundamental#things#to#know#about#sentinel#before#deploying","text":"You need at least three Sentinel instances for a robust deployment. The three Sentinel instances should be placed into computers or virtual machines that are believed to fail in an independent way. So for example different physical servers or Virtual Machines executed on different availability zones. Sentinel + Redis distributed system does not guarantee that acknowledged writes are retained(\u4fdd\u6301) during failures, since Redis uses asynchronous replication . However there are ways to deploy Sentinel that make the window to lose writes limited to certain moments, while there are other less secure ways to deploy it. You need Sentinel support in your clients. Popular client libraries have Sentinel support, but not all. There is no HA setup which is safe if you don't test from time to time in development environments, or even better if you can, in production environments, if they work. You may have a misconfiguration that will become apparent only when it's too late (at 3am when your master stops working). Sentinel, Docker, or other forms of Network Address Translation or Port Mapping should be mixed with care : Docker performs port remapping, breaking Sentinel auto discovery of other Sentinel processes and the list of slaves for a master. Check the section about Sentinel and Docker later in this document for more information.","title":"Fundamental things to know about Sentinel before deploying"},{"location":"Sentinel/Redis-Sentinel/#configuring#sentinel","text":"The Redis source distribution contains a file called sentinel.conf that is a self-documented example configuration file you can use to configure Sentinel, however a typical minimal configuration file looks like the following: sentinel monitor mymaster 127.0.0.1 6379 2 sentinel down-after-milliseconds mymaster 60000 sentinel failover-timeout mymaster 180000 sentinel parallel-syncs mymaster 1 sentinel monitor resque 192.168.1.3 6380 4 sentinel down-after-milliseconds resque 10000 sentinel failover-timeout resque 180000 sentinel parallel-syncs resque 5 You only need to specify the masters to monitor, giving to each separated master (that may have any number of slaves) a different name . There is no need to specify slaves , which are auto-discovered . Sentinel will update the configuration automatically with additional information about slaves (in order to retain the information in case of restart). The configuration is also rewritten every time a slave is promoted to master during a failover and every time a new Sentinel is discovered. The example configuration above, basically monitor two sets of Redis instances , each composed of a master and an undefined number of slaves. One set of instances is called mymaster , and the other resque . The meaning of the arguments of sentinel monitor statements is the following: sentinel monitor <master-group-name> <ip> <port> <quorum> For the sake of clarity, let's check line by line what the configuration options mean: The first line is used to tell Redis to monitor a master called mymaster , that is at address 127.0.0.1 and port 6379, with a quorum of 2. Everything is pretty obvious but the quorum argument: The quorum is the number of Sentinels that need to agree about the fact the master is not reachable, in order for really mark the slave as failing, and eventually start a fail over procedure if possible. However the quorum is only used to detect the failure . In order to actually perform a failover, one of the Sentinels need to be elected leader for the failover and be authorized to proceed. This only happens with the vote of the majority of the Sentinel processes . So for example if you have 5 Sentinel processes, and the quorum for a given master set to the value of 2, this is what happens: If two Sentinels agree at the same time about the master being unreachable, one of the two will try to start a failover. If there are at least a total of three Sentinels reachable , the failover will be authorized and will actually start. In practical terms this means during failures Sentinel never starts a failover if the majority of Sentinel processes are unable to talk (aka no failover in the minority partition). \u5b9e\u9645\u4e0a\uff0c\u8fd9\u610f\u5473\u7740\u5728\u6545\u969c\u671f\u95f4\uff0c\u5982\u679c\u5927\u591a\u6570Sentinel\u8fdb\u7a0b\u65e0\u6cd5\u901a\u8bdd\uff08\u5728\u5c11\u6570\u5206\u533a\u4e2d\u4e5f\u6ca1\u6709\u6545\u969c\u8f6c\u79fb\uff09\uff0cSentinel\u6c38\u8fdc\u4e0d\u4f1a\u542f\u52a8\u6545\u969c\u8f6c\u79fb\u3002","title":"Configuring Sentinel"},{"location":"Sentinel/Redis-Sentinel/#other#sentinel#options","text":"The other options are almost always in the form: sentinel <option_name> <master_name> <option_value> And are used for the following purposes: down-after-milliseconds is the time in milliseconds an instance should not be reachable (either does not reply to our PINGs or it is replying with an error) for a Sentinel starting to think it is down. parallel-syncs sets the number of slaves that can be reconfigured to use the new master after a failover at the same time. The lower the number, the more time it will take for the failover process to complete, however if the slaves are configured to serve old data, you may not want all the slaves to re-synchronize with the master at the same time. While the replication process is mostly non blocking for a slave, there is a moment when it stops to load the bulk data from the master. You may want to make sure only one slave at a time is not reachable by setting this option to the value of 1. parallel-syncs\u8bbe\u7f6e\u53ef\u5728\u540c\u4e00\u6545\u969c\u8f6c\u79fb\u540e\u91cd\u65b0\u914d\u7f6e\u4e3a\u4f7f\u7528\u65b0\u4e3b\u670d\u52a1\u5668\u7684\u4ece\u670d\u52a1\u5668\u6570\u3002 \u6570\u5b57\u8d8a\u5c0f\uff0c\u6545\u969c\u8f6c\u79fb\u8fc7\u7a0b\u5b8c\u6210\u6240\u9700\u7684\u65f6\u95f4\u5c31\u8d8a\u591a\uff0c\u4f46\u662f\u5982\u679c\u4ece\u5c5e\u670d\u52a1\u5668\u914d\u7f6e\u4e3a\u63d0\u4f9b\u65e7\u6570\u636e\uff0c\u5219\u53ef\u80fd\u4e0d\u5e0c\u671b\u6240\u6709\u4ece\u5c5e\u670d\u52a1\u5668\u540c\u65f6\u4e0e\u4e3b\u670d\u52a1\u5668\u91cd\u65b0\u540c\u6b65\u3002 \u867d\u7136\u590d\u5236\u8fc7\u7a0b\u5bf9\u4e8e\u4ece\u5c5e\u8bbe\u5907\u5927\u90e8\u5206\u662f\u975e\u963b\u585e\u7684\uff0c\u4f46\u662f\u6709\u4e00\u6bb5\u65f6\u95f4\u5b83\u505c\u6b62\u4ece\u4e3b\u8bbe\u5907\u52a0\u8f7d\u6279\u91cf\u6570\u636e\u3002 \u60a8\u53ef\u80fd\u5e0c\u671b\u901a\u8fc7\u5c06\u6b64\u9009\u9879\u8bbe\u7f6e\u4e3a\u503c1\u6765\u786e\u4fdd\u4e00\u6b21\u53ea\u80fd\u8bbf\u95ee\u4e00\u4e2a\u4ece\u7ad9\u3002 Additional options are described in the rest of this document and documented in the example sentinel.conf file shipped with the Redis distribution. All the configuration parameters can be modified at runtime using the SENTINEL SET command. See the Reconfiguring Sentinel at runtime section for more information.","title":"Other Sentinel options"},{"location":"Sentinel/Redis-Sentinel/#example#sentinel#deployments","text":"Now that you know the basic information about Sentinel, you may wonder where you should place your Sentinel processes , how much Sentinel processes you need and so forth. This section shows a few example deployments. We use ASCII art in order to show you configuration examples in a graphical format, this is what the different symbols means: +--------------------+ | This is a computer | | or VM that fails | | independently. We | | call it a \"box\" | +--------------------+ We write inside the boxes what they are running: +-------------------+ | Redis master M1 | | Redis Sentinel S1 | +-------------------+ Different boxes are connected by lines, to show that they are able to talk: +-------------+ +-------------+ | Sentinel S1 |---------------| Sentinel S2 | +-------------+ +-------------+ Network partitions are shown as interrupted lines using slashes: +-------------+ +-------------+ | Sentinel S1 |------ // ------| Sentinel S2 | +-------------+ +-------------+ Also note that: Masters are called M1, M2, M3, ..., Mn. Slaves are called R1, R2, R3, ..., Rn (R stands for replica ). Sentinels are called S1, S2, S3, ..., Sn. Clients are called C1, C2, C3, ..., Cn. When an instance changes role because of Sentinel actions, we put it inside square brackets, so [M1] means an instance that is now a master because of Sentinel intervention.","title":"Example Sentinel deployments"},{"location":"Sentinel/Redis-Sentinel/#example#1#just#two#sentinels#dont#do#this","text":"+----+ +----+ | M1 |---------| R1 | | S1 | | S2 | +----+ +----+ Configuration: quorum = 1 In this setup, if the master M1 fails, R1 will be promoted since the two Sentinels can reach agreement about the failure (obviously with quorum set to 1) and can also authorize\uff08\u6279\u51c6\uff09 a failover because the majority is two. So apparently it could superficially work, however check the next points to see why this setup is broken. If the box where M1 is running stops working, also S1 stops working. The Sentinel running in the other box S2 will not be able to authorize a failover, so the system will become not available. Note that a majority is needed in order to order different failovers, and later propagate the latest configuration to all the Sentinels . Also note that the ability to failover in a single side of the above setup, without any agreement, would be very dangerous: +----+ +------+ | M1 |----//-----| [M1] | | S1 | | S2 | +----+ +------+ In the above configuration we created two masters (assuming S2 could failover without authorization) in a perfectly symmetrical way. Clients may write indefinitely to both sides, and there is no way to understand when the partition heals what configuration is the right one, in order to prevent a permanent split brain condition . \u5728\u4e0a\u9762\u7684\u914d\u7f6e\u4e2d\uff0c\u6211\u4eec\u4ee5\u5b8c\u5168\u5bf9\u79f0\u7684\u65b9\u5f0f\u521b\u5efa\u4e86\u4e24\u4e2a\u4e3b\u670d\u52a1\u5668\uff08\u5047\u8bbeS2\u53ef\u4ee5\u5728\u672a\u7ecf\u6388\u6743\u7684\u60c5\u51b5\u4e0b\u8fdb\u884c\u6545\u969c\u8f6c\u79fb\uff09\u3002 \u5ba2\u6237\u7aef\u53ef\u4ee5\u65e0\u9650\u671f\u5730\u5411\u53cc\u65b9\u5199\u5165\uff0c\u5e76\u4e14\u65e0\u6cd5\u7406\u89e3\u5206\u533a\u4f55\u65f6\u6062\u590d\u6b63\u786e\u7684\u914d\u7f6e\uff0c\u4ee5\u9632\u6b62\u6c38\u4e45\u6027\u7684\u88c2\u8111\u60c5\u51b5\u3002 So please deploy at least three Sentinels in three different boxes always.","title":"Example 1: just two Sentinels, DON'T DO THIS"},{"location":"Sentinel/Redis-Sentinel/#example#2#basic#setup#with#three#boxes","text":"This is a very simple setup, that has the advantage to be simple to tune for additional safety. It is based on three boxes, each box running both a Redis process and a Sentinel process. +----+ | M1 | | S1 | +----+ | +----+ | +----+ | R2 |----+----| R3 | | S2 | | S3 | +----+ +----+ Configuration: quorum = 2 If the master M1 fails, S2 and S3 will agree about the failure and will be able to authorize a failover, making clients able to continue. In every Sentinel setup, being Redis asynchronously replicated, there is always the risk of losing some write because a given acknowledged write may not be able to reach the slave which is promoted to master. However in the above setup there is an higher risk due to clients partitioned away with an old master, like in the following picture: +----+ | M1 | | S1 | <- C1 (writes will be lost) +----+ | / / +------+ | +----+ | [M2] |----+----| R3 | | S2 | | S3 | +------+ +----+","title":"Example 2: basic setup with three boxes"},{"location":"Sentinel/Redis-Sentinel/#a#quick#tutorial","text":"","title":"A quick tutorial"},{"location":"Sentinel/Redis-Sentinel/#asking#sentinel#about#the#state#of#a#master","text":"","title":"Asking Sentinel about the state of a master"},{"location":"Sentinel/Redis-Sentinel/#obtaining#the#address#of#the#current#master","text":"","title":"Obtaining the address of the current master"},{"location":"Sentinel/Redis-Sentinel/#testing#the#failover","text":"","title":"Testing the failover"},{"location":"Sentinel/Redis-Sentinel/#sentinel#api","text":"","title":"Sentinel API"},{"location":"Sentinel/Redis-Sentinel/#sentinel#commands","text":"","title":"Sentinel commands"},{"location":"Sentinel/Redis-Sentinel/#reconfiguring#sentinel#at#runtime","text":"","title":"Reconfiguring Sentinel at Runtime"},{"location":"Sentinel/Redis-Sentinel/#adding#or#removing#sentinels","text":"","title":"Adding or removing Sentinels"},{"location":"Sentinel/Redis-Sentinel/#removing#the#old#master#or#unreachable#slaves","text":"","title":"Removing the old master or unreachable slaves"},{"location":"Sentinel/Redis-Sentinel/#pubsub#messages","text":"","title":"Pub/Sub Messages"},{"location":"Sentinel/Redis-Sentinel/#handling#of#-busy#state","text":"","title":"Handling of -BUSY state"},{"location":"Sentinel/Redis-Sentinel/#slaves#priority","text":"","title":"Slaves priority"},{"location":"Sentinel/Redis-Sentinel/#sentinel#and#redis#authentication","text":"","title":"Sentinel and Redis authentication"},{"location":"Sentinel/Redis-Sentinel/#configuring#sentinel#instances#with#authentication","text":"","title":"Configuring Sentinel instances with authentication"},{"location":"Sentinel/Redis-Sentinel/#more#advanced#concepts","text":"In the following sections we'll cover a few details about how Sentinel work, without to resorting to implementation details and algorithms that will be covered in the final part of this document.","title":"More advanced concepts"},{"location":"Sentinel/Redis-Sentinel/#sdown#and#odown#failure#state","text":"","title":"SDOWN and ODOWN failure state"},{"location":"Sentinel/Redis-Sentinel/#sentinels#and#slaves#auto#discovery","text":"","title":"Sentinels and Slaves auto discovery"},{"location":"Sentinel/Redis-Sentinel/#sentinel#reconfiguration#of#instances#outside#the#failover#procedure","text":"","title":"Sentinel reconfiguration of instances outside the failover procedure"},{"location":"Sentinel/Redis-Sentinel/#slave#selection#and#priority","text":"","title":"Slave selection and priority"},{"location":"Sentinel/Redis-Sentinel/#algorithms#and#internals","text":"In the following sections we will explore the details of Sentinel behavior. It is not strictly needed for users to be aware of all the details, but a deep understanding of Sentinel may help to deploy and operate Sentinel in a more effective way.","title":"Algorithms and internals"},{"location":"Sentinel/Redis-Sentinel/#quorum","text":"","title":"Quorum"}]}